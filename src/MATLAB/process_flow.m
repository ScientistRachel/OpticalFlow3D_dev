function process_flow(imDir,imName,fileType,spatialDimensions,xyzSig,tSig,wSig)
    % Function to organize commands to calc_flow3D given an image or image
    % sequence for processing. The script can parse a two tif formats. If your
    % data is another format, this is the function to change to adapt the code
    % to your uses.
    %
    % OneTif files are assumed to be created using ImageJ when reading metadata.
    % These files are read using the function imread_big by Tristan Ursell.
    % See more at: https://www.mathworks.com/matlabcentral/fileexchange/61376-imread_big-read-in-tiff-stacks-larger-than-4gb
    % This allows for reading tifs > 4GB and is faster than tiffReadVolume.
    % It works on ImageJ generted tifs, but not in the more general case, and
    % thus is not used for fileType SequenceT (which uses tiffReadVolume).
    %
    % INPUTS:
    % imDir             = Full path to the folder of image(s) to process
    % imName            = File name for the image(s) to process, excluding .tif.
    %                    See fileType for more information on formatting this name.
    % fileType          = Either 'OneTif' or 'SequenceT.' In the case 'OneTif',
    %                    the entire timelapse and all z-slices are assumed to 
    %                    be saved in one single .tif file, and in the format 
    %                    generated by ImageJ. In the case of 'SequenceT', the
    %                    images are assumed to be saved as a sequence, with one
    %                    tif per timepoint (but all z-slices saved as one tif).
    %                    In this case, imName must be specified with a wildcard
    %                    for the time label in the file names. For a list of
    %                    files with names:
    %                       myexperiment_t000_ch0.tif
    %                       myexperiment_t001_ch0.tif
    %                       myexperiment_t002_ch0.tif
    %                   the correct imName would be 'myexperiment_t*_ch0'.
    % spatialDimensions = Either 2 (2D) or 3 (3D). Default 3.
    % xyzSig            = sigma value for smoothing in all spatial dimensions. Default 3.
    %                    Larger values remove noise but remove spatial detail.
    % tSig              = sigma value for smoothing in the temporal dimension. Default 1.
    %                    Larger values remove noise but remove temporal detail.
    % wSig              = sigma value for Lucas-Kanade neighborhood. Default is 4.
    %                    Larger values include a larger neighboorhood in the
    %                    Lucas-Kanade constraint and will smooth over small features.
    %
    % OUTPUTS:
    % This function does not output variables to the workspace but rather
    % saves files for the output variables.
    %
    % Change Log:
    % 2025/01/31 Rachel M. Lee - Created function
    % 2025/03/20 Rachel M. Lee - Updated for MATLAB 2024b
    % 2025/03/27 Rachel M. Lee - Use TIFF for image loading
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    %% Check Inputs, Implement Defaults, and Set Up Paths %%%%%%%%%%%%%%%%%%%%%
    
    try
        % imread_big is used to open tifs > 4 GB
        addpath("imread_big.m\")
    catch err
        disp('Please include imread_big as a subfolder of this directory')
        rethrow(err)
    end
    
    % Check that the directory exists
    if ~exist(imDir,'dir')
        error(['Image directory does not exist: ' imDir])
    end
    if ~strcmp(imDir(end),filesep)
        imDir(end+1) = filesep;
    end
    
    % Check that the image files exist and that the type is correct
    if ~exist('fileType','var') || isempty(fileType)
        fileType = 'SequenceT';
    end
    
    list = dir([imDir imName '.tif']);
    if isempty(list)
        error(['Image file not found: ' imDir filesep imName])
    end
    if strcmp(fileType,'OneTif')
        if length(list) > 1
            error(['Unexpected number of files for ' imName])
        end
    elseif strcmp(fileType,'SequenceT')
        if length(list) < 3*tSig+1 % Minimum required for calc_flow
            error(['Image sequence found for file name ' imName ' only contains ' num2str(length(list)) ' files. Minimum 3*tsig+1 files required.'])
        end
    else
        error('fileType must be either OneTif or SequenceT')
    end
    
    % Must be either 3D or 2D processing
    if ~exist('spatialDimensions','var') || isempty(spatialDimensions)
        disp('Using default spatialDimensions value of 3...')
        spatialDimensions = 3;
    end
    if spatialDimensions~=3 && spatialDimensions~=2
        error('Number of spatial dimensions must be either 2 or 3.')
    end
    
    % Implement default optical flow parameter values if they are not specified
    if ~exist('xyzSig','var') || isempty(xyzSig)
        disp('Using default xyzSig value of 3...')
        xyzSig = 3;
    end
    if ~exist('tSig','var') || isempty(tSig)
        tSig = 1;
        disp('Using default tSig value of 1...')
    end
    if ~exist('wSig','var') || isempty(wSig)
        wSig = 4;
        disp('Using default wSig value of 4...')
    end
    
    % Set up a save folder
    imNameSave = erase(imName,'*'); % don't keep any regular expressions
    % Main folder is inside the image directory
    % Subfolder is the imName
    if spatialDimensions == 3
        savedir = [imDir filesep 'OpticalFlow3D' filesep imNameSave];
    elseif spatialDimensions == 2
        savedir = [imDir filesep 'OpticalFlow2D' filesep imNameSave];
    end
    if ~exist(savedir,'dir')
        mkdir(savedir)
    end
    
    %% Metadata parsing and parameter saving %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    %%%%%% Get the metadata
    if strcmp(fileType,'OneTif') % assuming a tif made with ImageJ containing all z and all t
    
        meta = imfinfo([imDir imName '.tif'],'tif');
        Nx = meta(1).Width;
        Ny = meta(1).Height;
        if ~isfield(meta,'ImageDescription')
            error('OneTif file format must include the ImageDescription tag in the format generated by ImageJ.')
        end
        Nz = meta(1).ImageDescription;
        if spatialDimensions == 3
            Nz = strsplit(Nz,'\n');
            Nt = strsplit(Nz{4},'=');
            Nt = str2double(Nt{end});
            Nz = strsplit(Nz{3},'=');
            Nz = str2double(Nz{end});
        elseif spatialDimensions == 2
            Nz = strsplit(Nz,'\n');
            Nt = strsplit(Nz{2},'=');
            Nt = str2double(Nt{end});
            Nz = strsplit(Nz{3},'=');
            Nz = str2double(Nz{end});
            Nz = Nz/Nt; % Images/Frames, should = 1, this is a check
        else
            error('Spatial Dimension must be 2 or 3')
        end
        
        disp([char(datetime('now')) ' - Image Size: ' num2str(Nx) ' x ' num2str(Ny) ' x ' num2str(Nz) ' x ' num2str(Nt)])
        
        % Get frames as a sanity check (this is slow but better to make sure this is working now)
        [~,Nframes]= imread_big([imDir imName '.tif']);
        if Nt*Nz ~= Nframes
            error('unexpected frame number')
        end
    
    elseif strcmp(fileType,'SequenceT') % assuming 1 tif per timepoint that is a z-stack (or slice for 2D)
    
        meta = imfinfo([imDir list(1).name],'tif');
        Nx = meta(1).Width;
        Ny = meta(1).Height;
        Nz = length(meta);
        Nt = length(list);
    
    end
    
    % Check that spatial dimension and Nz are appropriate
    if spatialDimensions == 2
        if Nz~=1
            error('More than one z-slice detected for 2D processing')
        end
    elseif spatialDimensions == 3
        if Nz <= 1
            if Nz == 1
                error(['3D processing requested but ' num2str(Nz) ' slice detected'])
            else
                error(['3D processing requested but ' num2str(Nz) ' slices detected'])
            end
        end
    end
    
    %%%%%% Time chunking
    % If each processed file contains less than 6*tSig+1 frames, there will be
    % edge effects in the time smoothing. The data will be chunked such that
    % each analyzed frame is processed along with its surrounding frames.
    NtChunk = 6*tSig + 1;
    if ~mod(NtChunk,2) % enforce odd number
        NtChunk = NtChunk + 1;
    end
    NtSlice = ceil(NtChunk/2);
    
    %%%%%% Save the parameters
    param = table(xyzSig,tSig,wSig,Nx,Ny,Nz,Nt);
    writetable(param,[savedir filesep imNameSave '_parameters.csv'])
    
    %% Processing Loop %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    disp('Note: Regardless of the input filenames, the first image = frame 1.')
    disp('If your file names start from 0, you will need adjust your')
    disp('indexing accordingly when analyzing the output tiff files.')
    disp(' ')
    
    % Because >2*3*tSig time frames are necessary for processing, some frames at
    % the start and the end of the timelapse will be ignored.
    for hh = 1:NtSlice-1
        disp([char(datetime('now')) ' - No data will be saved for frame ' num2str(hh) ' to avoid edge effects'])
    end
    
    
    if strcmp(fileType,'OneTif') % assuming a tif made with ImageJ containing all z and all t
    
        if spatialDimensions == 3
    
            for hh = 1:Nt-NtChunk+1 % If you have enough memory, this could become a parfor loop.
            
                loopStart = datetime('now');
                disp([char(datetime('now')) ' - Processing frame ' num2str(hh+NtSlice-1) '...'])
            
                % Load images
                [images,~]= imread_big([imDir imName '.tif'],[Nz*(hh-1)+1 Nz*(hh+NtChunk-1)]);
                images = reshape(images,[Nx,Ny,Nz,NtChunk]);
                images = double(images); % For calculations
            
                %  Run the optical flow
                [vx,vy,vz,rel] = calc_flow3D(images ,xyzSig, tSig, wSig);
            
                % Save this frame
                TIFFwrite([savedir filesep imNameSave '_vx_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],vx)
                TIFFwrite([savedir filesep imNameSave '_vy_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],vy)
                TIFFwrite([savedir filesep imNameSave '_vz_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],vz)
                TIFFwrite([savedir filesep imNameSave '_rel_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],rel)
            
                clear rel vx vy vz images
            
                framestime = datetime('now');
                disp([char(datetime('now')) ' - Frame ' num2str(hh+NtSlice-1) ' saved.  Duration: ' char(framestime-loopStart)])
            
            end
    
        elseif spatialDimensions == 2
    
                for hh = 1:Nt-NtChunk+1 % If you have enough memory, this could become a parfor loop.
            
                loopStart = datetime('now');
                disp([char(datetime('now')) ' - Processing frame ' num2str(hh+NtSlice-1) '...'])
            
                % Load images
                [images,~]= imread_big([imDir imName '.tif'],[Nz*(hh-1)+1 Nz*(hh+NtChunk-1)]);
                images = reshape(images,[Nx,Ny,NtChunk]);
                images = double(images); % For calculations
            
                %  Run the optical flow
                [vx,vy,rel] = calc_flow2D(images ,xyzSig, tSig, wSig);
            
                % Save this frame
                % -v6 speeds things up, but could be a problem for larger images
                TIFFwrite([savedir filesep imNameSave '_vx_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],vx)
                TIFFwrite([savedir filesep imNameSave '_vy_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],vy)
                TIFFwrite([savedir filesep imNameSave '_rel_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],rel)
            
                clear rel vx vy images
            
                framestime = datetime('now');
                disp([char(datetime('now')) ' - Frame ' num2str(hh+NtSlice-1) ' saved.  Duration: ' char(framestime-loopStart)])
            
                end
    
        else
            error('Spatial Dimension must be 2 or 3')
        end
    
    elseif strcmp(fileType,'SequenceT') % assuming 1 tif per timepoint that is a z-stack (or slice for 2D)
    
        if spatialDimensions == 3
    
            for hh = 1:Nt-NtChunk+1 % If you have enough memory, this could become a parfor loop.
        
                loopStart = datetime('now');
                disp([char(datetime('now')) ' - Processing frame ' num2str(hh+NtSlice-1) '...'])
            
                % Load images
                images = zeros(Ny,Nx,Nz,NtChunk);
                for jj = 1:NtChunk
                    images(:,:,:,jj) = TIFFvolume([imDir list(jj+hh-1).name],Nx,Ny,Nz);
                end
                images = double(images); % For calculations
            
                %  Run the optical flow
                [vx,vy,vz,rel] = calc_flow3D(images ,xyzSig, tSig, wSig);
            
                % Save this frame
                TIFFwrite([savedir filesep imNameSave '_vx_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],vx)
                TIFFwrite([savedir filesep imNameSave '_vy_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],vy)
                TIFFwrite([savedir filesep imNameSave '_vz_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],vz)
                TIFFwrite([savedir filesep imNameSave '_rel_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],rel)
            
                clear rel vx vy vz images
            
                framestime = datetime('now');
                disp([char(datetime('now')) ' - Frame ' num2str(hh+NtSlice-1) ' saved.  Duration: ' char(framestime-loopStart)])
        
            end
    
        elseif spatialDimensions == 2

            warning('off','imageio:tiffutils:libtiffWarning') % libtiff may provide unncessary warnings about the ColorMap for 2D images made with ImageJ. Don't provide this warning to the user.
    
            for hh = 1:Nt-NtChunk+1 % If you have enough memory, this could become a parfor loop.
        
                loopStart = datetime('now');
                disp([char(datetime('now')) ' - Processing frame ' num2str(hh+NtSlice-1) '...'])
            
                % Load images
                images = zeros(Ny,Nx,NtChunk);
                for jj = 1:NtChunk
                    images(:,:,jj) = TIFFvolume([imDir list(jj+hh-1).name],Nx,Ny,1);
                end
                images = double(images); % For calculations
            
                %  Run the optical flow
                [vx,vy,rel] = calc_flow2D(images ,xyzSig, tSig, wSig);
            
                % Save this frame
                TIFFwrite([savedir filesep imNameSave '_vx_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],vx)
                TIFFwrite([savedir filesep imNameSave '_vy_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],vy)
                TIFFwrite([savedir filesep imNameSave '_rel_t' num2str(hh+NtSlice-1,'%04u') '.tiff'],rel)
            
                clear rel vx vy images
            
                framestime = datetime('now');
                disp([char(datetime('now')) ' - Frame ' num2str(hh+NtSlice-1) ' saved.  Duration: ' char(framestime-loopStart)])
        
            end

            warning('on','imageio:tiffutils:libtiffWarning') % Reset the warning state for other things the user might want to do
    
        else
            error('Spatial Dimension must be 2 or 3')
        end
    
    end
    
    % Because >3*tSig time frames are necessary for processing, some frames at
    % the start and the end of the timelapse will be ignored.
    for hh = Nt-NtSlice+2:Nt
        disp([char(datetime('now')) ' - No data will be saved for frame ' num2str(hh) ' to avoid edge effects'])
    end

end

%% I/O Functions
% Use TIFF to load in 3D volumes
function vol = TIFFvolume(filename,Nx,Ny,frames)

    vol = uint16(ones(Ny,Nx,frames));
    intiff = Tiff(filename,"r");
    for ii = 1:frames-1
        vol(:,:,ii) = read(intiff);
        nextDirectory(intiff);
    end
    vol(:,:,frames) = read(intiff);

end

% Use TIFF to save float tifs
function TIFFwrite(filename,A)

    % TIFF Tags
    tagstruct.ImageLength = size(A,1);
    tagstruct.ImageWidth = size(A,2);
    tagstruct.SamplesPerPixel = 1;
    tagstruct.PlanarConfiguration = Tiff.PlanarConfiguration.Chunky;
    tagstruct.BitsPerSample = 64;
    tagstruct.SampleFormat = Tiff.SampleFormat.IEEEFP;
    tagstruct.Photometric = Tiff.Photometric.MinIsBlack;
    tagstruct.Compression = Tiff.Compression.LZW;

    outtiff = Tiff(filename,'w8'); % Using bigtiff writing
    for ii = 1:size(A,3)-1
        outtiff.setTag(tagstruct);
        outtiff.write(A(:,:,ii));
        outtiff.writeDirectory();
    end
    outtiff.setTag(tagstruct);
    outtiff.write(A(:,:,size(A,3)));

    % Close the file
    outtiff.close();
    
end
